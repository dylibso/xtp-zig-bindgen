// THIS FILE WAS GENERATED BY `xtp-zig-bindgen`. DO NOT EDIT.
const std = @import("std");
const extism = @import("extism-pdk");
<% if(JSON.stringify(schema).includes("date-time")) { -%>
const DateTime = @import("datetime").DateTime;
<% } -%>

const _host = struct {
<% if (schema.imports.length > 0) { -%>
<% Object.values(schema.imports).forEach(imp => { -%>
    extern "extism:host/user" fn <%- imp.name %>(<%- imp.input ? "u64" : null %>) <%- imp.output ? "u64" : "void" %>;
<% }) -%>
<% } -%>
};

const _plugin = extism.Plugin.init(std.heap.wasm_allocator);

<% if (schema.imports.length > 0) { -%>
/// Host contains all of the provided import functions made available to 
/// plugins by the host platform where your plugin will run.
pub const Host = struct {
<% schema.imports.forEach(imp => { %>
	<% if (hasComment(imp)) -%>
	/// <%- formatCommentBlock(imp.description, "/// ") %>
	<% if (imp.input && hasComment(imp.input)) { -%>
	/// It takes input of <%- toZigType(imp.input) %> (<%- formatCommentLine(imp.input.description) %>)
	<% } -%>
	<% if (imp.output && hasComment(imp.output)) { -%>
	/// And it returns an output <%- toZigType(imp.output) %> (<%- formatCommentLine(imp.output.description) %>)
	<% } -%>
	pub fn <%- imp.name %>(<%- imp.input ? `input: ${toZigType(imp.input)}` : null %>) !<%- imp.output ? `${toZigType(imp.output)}` : "void" %> {
	<% if (imp.input) { -%>
		<% if (imp.input.contentType === 'application/json') { -%>
		const b = try std.json.stringifyAlloc(_plugin.allocator, input, .{});
        const inMem = _plugin.allocateBytes(b);
		<% } else if (imp.input.$ref && imp.input.$ref.enum) { -%>
		const inMem = _plugin.allocateBytes(@tagName(input));
		<% } else if (imp.input.contentType === 'text/plain; charset=UTF-8') { -%>
		if (!std.unicode.utf8ValidateSlice(input)) {
      return error.InvalidUtf8;
    }
    const inMem = _plugin.allocateBytes(input);
		<% } else if (imp.input.type === 'string') { -%>
		const inMem = _plugin.allocateBytes(input);
		<% } else { -%>
		const inMem = _plugin.allocateBytes(input);
		<% } -%>
		if (inMem.offset == 0) {
				return error.ExtismBadMemory;
		}
		defer inMem.free();

		<% if (imp.output) { -%>const ptr =<% } -%> _host.<%- imp.name %>(inMem.offset);
	<% } else { -%>
		<% if (imp.output) { -%>const ptr =<% } -%> _host.<%- imp.name %>();
	<% } -%>
	<% if (imp.output) { -%>
		if (ptr == 0) {
				return error.ExtismBadMemory;
		}
		const outMem = _plugin.findMemory(ptr);
        defer outMem.free();
		<% if (imp.output.contentType === 'application/json') { -%>
        const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        const out = try std.json.parseFromSlice(<%- toZigType(imp.output) %>, _plugin.allocator, buffer, .{ .allocate = .alloc_always });    
        return out.value;
		<% } else if (imp.output.contentType === 'text/plain; charset=UTF-8') { -%>
        const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        if (!std.unicode.utf8ValidateSlice(buffer)) {
            return error.InvalidUtf8;
        }
        return buffer;
		<% } else if (imp.output.type === 'string') { -%>
		const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        return buffer;
		<% } else { -%>
        const buffer = try _plugin.allocator.alloc(u8, @intCast(outMem.length));
        outMem.load(buffer);
        return buffer;
		<% } -%>
	<% } -%>
	}
<% }) %>
};
<% } -%>

<% Object.values(schema.schemas).forEach(schema => { %>
	<% if (schema.properties.length > 0) { -%>
	/// <%- formatCommentBlock(schema.description, "/// ") %>
	pub const <%- makeStructName(schema.name) %> = struct {
		<% schema.properties.forEach(p => { -%>
		<% if (p.description) { -%>
		/// <%- formatCommentBlock(p.description, "/// ") %>
		<% } -%>
		<%- p.name %>: <%- p.nullable ? "?" : null %><%- toZigType(p) %>,
		<% }) %>
	};
    <% } else if (schema.enum) { %>
			<% if (schema.description) { -%>
			/// <%- formatCommentBlock(schema.description, "/// ") %>
			<% } -%>
			pub const <%- makeStructName(schema.name) %> = enum {
				<% schema.enum.forEach((variant) => { -%>
				<%- variant %>,
				<% }) -%>
			};
    <% } -%>
<% }) %>
