// THIS FILE WAS GENERATED BY `xtp-zig-bindgen`. DO NOT EDIT.
const std = @import("std");
const extism = @import("extism-pdk");

const user = @import("main.zig");
const schema = @import("schema.zig");

const _plugin = extism.Plugin.init(std.heap.wasm_allocator);

const ERR_PRINTING_MSG: []const u8 = "std.fmt.allocPrint failed when formatting plugin error";

<% schema.exports.forEach(ex => { -%>
export fn <%- ex.name %>() i32 {
  <% if (ex.input) { -%>
    // Get the input data
    <% if (ex.input.contentType === 'application/json') { -%>
    // in JSON
    const jsonInput = _plugin.getJsonOpt(schema.<%- ex.input.$ref.name %>, .{}) catch |err| {
        const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
        _plugin.setError(msg);
        return -1;
    };
    defer jsonInput.deinit();
    
    const input = jsonInput.value();
    <% } else if (ex.input.type === 'string') { -%>
        <% if (ex.input.$ref && ex.input.$ref.enum) { -%>		
        // as a string Enum
        const s = _plugin.getInput();
        defer _plugin.allocator.free(s);
        const input = std.enums.nameCast(<%- ex.input.$ref.name %>, s);
	    <% } else { -%>
        // as a string
		const input = _plugin.getInput() catch |err| {
            const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
            _plugin.setError(msg);
            return -1;
        };
        defer _plugin.allocator.free(input);
		<% } %>
    <% } else { -%>
    // as a buffer
    const input = _plugin.getInput() catch |err| {
        const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
        _plugin.setError(msg);
        return -1;
    };
    defer _plugin.allocator.free(input);
    <% } -%>

	// Call the implementation function
    <% if (ex.output) { -%>
    const output = user.<%- ex.name %>(input) catch |err| {
        const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
        _plugin.setError(msg);
        return -1;
    };
    <% } else { -%>
    user.<%- ex.name %>(input) catch |err| {
        const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
        _plugin.setError(msg);
        return -1;
    };
    <% } -%>
  <% } else { -%>
    <% if (ex.output) { -%>
    const output = user.<%- ex.name %>() catch |err| {
        const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
        _plugin.setError(msg);
        return -1;
    };
    <% } else { -%>
    user.<%- ex.name %>() catch |err| {
        const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
        _plugin.setError(msg);
        return -1;
    };
    <% } -%>
  <% } -%>

  <% if (ex.output) { -%>
    <% if (ex.output.contentType === 'application/json') { -%>
    _plugin.outputJson(output, .{}) catch |err| {
        const msg = std.fmt.allocPrint(_plugin.allocator, "{}", .{err}) catch ERR_PRINTING_MSG;
        _plugin.setError(msg);
        return -1;
    };
    <% } else if (ex.output.type === 'text/plain; charset=UTF-8') { -%>
    if (!std.unicode.utf8ValidateSlice(input)) {
      return error.InvalidUtf8;
    }
    _plugin.output(output);
    <% } else if (ex.output.type === 'string') { -%>
    _plugin.output(output);
    <% } else { -%>
    _plugin.output(output);
    <% } -%>
  <% } -%>
  return 0;
}

<% }) %>